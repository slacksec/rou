<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Merry Christmas üéÑ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      background: radial-gradient(circle at top, #2a395a 0%, #050814 55%, #02030a 100%);
      color: #ffffff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow-x: hidden;
    }

    header {
      position: sticky;
      top: 0;
      z-index: 50;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(6px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .nav {
      max-width: 1100px;
      margin: 0 auto;
      padding: 10px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .nav-left {
      font-weight: 600;
      font-size: 0.95rem;
    }

    .nav-links {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      font-size: 0.85rem;
    }

    .nav-links a {
      color: #ffe48b;
      text-decoration: none;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid transparent;
    }

    .nav-links a:hover {
      border-color: rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.08);
    }

    .back-btn {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      background: rgba(0, 0, 0, 0.4);
      color: #ffffff;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .back-btn:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    main {
      max-width: 1100px;
      margin: 0 auto;
      padding: 20px 16px 40px;
    }

    section {
      background: rgba(0, 0, 0, 0.38);
      border-radius: 16px;
      padding: 16px;
      margin-bottom: 18px;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    section h2 {
      margin-bottom: 8px;
      font-size: 1.3rem;
    }

    /* Hero + tree */
    .hero {
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
      gap: 16px;
      align-items: center;
    }

    .hero-title {
      font-size: clamp(2rem, 2vw + 1.4rem, 2.6rem);
      margin-bottom: 6px;
      text-align: left;
    }

    .hero-text {
      font-size: 0.95rem;
      opacity: 0.9;
      line-height: 1.5;
    }

    .hero-tip {
      margin-top: 6px;
      font-size: 0.9rem;
      opacity: 0.8;
    }

    .tree-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }

    .tree {
      position: relative;
      width: 170px;
      height: 260px;
      cursor: pointer;
    }

    .tree-layer {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      border-left: 80px solid transparent;
      border-right: 80px solid transparent;
      border-bottom: 90px solid #0b8a3e;
      filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.7));
      z-index: 1;
    }

    .layer-top {
      top: 28px;
      border-bottom-color: #0b8a3e;
    }

    .layer-mid {
      top: 78px;
      border-bottom-color: #0fa34c;
    }

    .layer-bottom {
      top: 128px;
      border-bottom-color: #16ca5e;
    }

    .tree-trunk {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 38px;
      height: 40px;
      background: #5c3b1e;
      border-radius: 4px;
      z-index: 1;
    }

    .tree-star {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 2.1rem;
      filter: drop-shadow(0 0 8px rgba(255, 255, 160, 1));
      z-index: 3;
      pointer-events: none;
    }

    .tree-lights span {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #555555;   /* OFF = grey */
      box-shadow: none;      /* no glow when off */
      z-index: 2;
    }

    .tree-lights span:nth-child(1) { top: 90px; left: 50px; }
    .tree-lights span:nth-child(2) { top: 110px; left: 95px; }
    .tree-lights span:nth-child(3) { top: 140px; left: 65px; }
    .tree-lights span:nth-child(4) { top: 155px; left: 115px; }
    .tree-lights span:nth-child(5) { top: 185px; left: 45px; }

    .lights-on .tree-lights span {
      background: #ffd166;
      box-shadow: 0 0 8px rgba(255, 220, 160, 0.9);
      animation: twinkle 1.2s infinite alternate;
    }

    @keyframes twinkle {
      from { opacity: 0.5; transform: scale(0.8); }
      to { opacity: 1; transform: scale(1.2); }
    }

    .tree-label {
      font-size: 0.85rem;
      opacity: 0.82;
    }

    /* Countdown */
    .countdown-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
    }

    .countdown-item {
      flex: 1;
      min-width: 90px;
      text-align: center;
      padding: 8px;
      border-radius: 12px;
      background: rgba(5, 31, 66, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .countdown-number {
      font-size: 1.5rem;
      font-weight: 700;
    }

    .countdown-label {
      font-size: 0.78rem;
      opacity: 0.8;
    }

    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }

    .pill-btn {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      background: rgba(0, 0, 0, 0.45);
      color: #ffffff;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .pill-btn:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    /* Presents */
    .presents-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 14px;
      margin-top: 10px;
    }

    .present {
      position: relative;
      height: 120px;
      border-radius: 16px;
      overflow: hidden;
      cursor: pointer;
    }

    .present-box {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(145deg, #d7263d, #ff4f4f);
      border: 2px solid rgba(255, 255, 255, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      overflow: hidden;
      transition: opacity 0.35s ease, transform 0.35s ease;
    }

    .present-box::before {
      content: "";
      position: absolute;
      inset: 0;
      width: 18px;
      margin: 0 auto;
      background: #ffe066;
      mix-blend-mode: screen;
    }

    .present-box::after {
      content: "";
      position: absolute;
      inset: 0;
      height: 18px;
      margin: auto 0;
      background: #ffe066;
      mix-blend-mode: screen;
    }

    .present-label {
      position: relative;
      z-index: 1;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .present-text {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px;
      text-align: center;
      font-size: 0.85rem;
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .present.opened .present-box {
      opacity: 0;
      transform: scale(0.85);
      pointer-events: none;
    }

    .present.opened .present-text {
      opacity: 1;
    }

    .present-message {
      margin-top: 10px;
      font-size: 0.88rem;
      min-height: 1.2em;
      opacity: 0.9;
    }

    /* Santa & Boss sections */
    .character-row {
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      align-items: flex-start;
    }

    .character-card {
      flex: 1;
      min-width: 260px;
      background: rgba(5, 31, 66, 0.9);
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 10px 12px;
    }

    .character-face {
      font-size: 2.4rem;
      margin-bottom: 6px;
    }

    .character-name {
      font-weight: 700;
      margin-bottom: 4px;
    }

    .character-desc {
      font-size: 0.85rem;
      opacity: 0.85;
      margin-bottom: 8px;
    }

    .character-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 8px;
    }

    .char-btn {
      padding: 5px 10px;
      font-size: 0.82rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      background: rgba(0, 0, 0, 0.45);
      color: #ffffff;
      cursor: pointer;
    }

    .char-btn:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    .character-output {
      font-size: 0.86rem;
      min-height: 2.4em;
      line-height: 1.4;
    }

    /* Boss game */
    #bossGame {
      width: 100%;
      max-width: 480px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: #061226;
      display: block;
      margin: 6px 0;
    }

    .boss-info {
      font-size: 0.78rem;
      opacity: 0.85;
      margin-bottom: 4px;
    }

    .boss-game-text {
      margin-top: 4px;
      font-size: 0.85rem;
      min-height: 2.4em;
    }

    /* Santa sleigh */
    .santa {
      position: fixed;
      top: 12%;
      left: -200px;
      font-size: 2rem;
      z-index: 10;
      pointer-events: none;
      animation: fly 22s linear infinite;
    }

    @keyframes fly {
      0% { transform: translateX(0); opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translateX(130vw); opacity: 0; }
    }

    /* Snow */
    .snowflake {
      position: fixed;
      top: -10px;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: white;
      opacity: 0.8;
      pointer-events: none;
      z-index: 1;
      animation: fall var(--duration) linear forwards;
    }

    @keyframes fall {
      to {
        transform: translateY(105vh);
        opacity: 0.2;
      }
    }

    /* Sparkles */
    .sparkle {
      position: fixed;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: radial-gradient(circle, #ffffff 0, #ffe48b 40%, transparent 70%);
      pointer-events: none;
      z-index: 5;
      animation: sparkle-pop 0.7s ease-out forwards;
    }

    @keyframes sparkle-pop {
      from { opacity: 1; transform: scale(0.2); }
      to { opacity: 0; transform: scale(1.4); }
    }

    footer {
      text-align: center;
      font-size: 0.8rem;
      opacity: 0.7;
      padding-bottom: 20px;
    }

    @media (max-width: 700px) {
      .hero {
        grid-template-columns: minmax(0, 1fr);
      }
      .hero-title,
      .hero-text,
      .hero-tip {
        text-align: left;
      }
    }
  </style>
</head>
<body>

  <!-- Flying Santa decoration -->
  <div class="santa">üéÖü¶åü¶åü¶å</div>

  <header>
    <div class="nav">
      <div class="nav-left">üéÑ Calvin‚Äôs Christmas World</div>
      <div class="nav-links">
        <a href="#countdown">Countdown</a>
        <a href="#tree-section">Tree</a>
        <a href="#presents">Presents</a>
        <a href="#santa-boss">Santa & Boss</a>
      </div>
      <button class="back-btn" onclick="location.href='index.html'">‚¨Ö Back</button>
    </div>
  </header>

  <main>
    <!-- Hero -->
    <section class="hero">
      <div>
        <h1 class="hero-title">‚ú® Merry Christmas & Happy Holidays ‚ú®</h1>
        <p class="hero-text">
          Welcome to the secret Christmas page. Click things. See what happens.
          Snow falls, lights blink, Santa talks, and there‚Äôs a crown Boss waiting for elf bonks.
        </p>
        <p class="hero-tip">
          Tip: Sword = 4 dmg, Bow = 3 dmg, Mace = 1 dmg on ground but 7 dmg if you jump-hit (crit).
        </p>
      </div>
      <div class="tree-wrapper" id="tree-section">
        <div id="tree" class="tree lights-on" title="Click to toggle lights">
          <!-- triangles first (behind) -->
          <div class="tree-layer layer-top"></div>
          <div class="tree-layer layer-mid"></div>
          <div class="tree-layer layer-bottom"></div>
          <!-- trunk -->
          <div class="tree-trunk"></div>
          <!-- lights -->
          <div class="tree-lights">
            <span></span><span></span><span></span><span></span><span></span>
          </div>
          <!-- star on top -->
          <div class="tree-star">‚≠ê</div>
        </div>
        <div id="treeLabel" class="tree-label">Lights: ON (click to toggle)</div>
      </div>
    </section>

    <!-- Countdown + controls -->
    <section id="countdown">
      <h2>‚è∞ Countdown to Christmas</h2>
      <p style="font-size:0.9rem; opacity:0.85;">
        Counting down to midnight on 25 December (your local time).
      </p>

      <div class="countdown-grid">
        <div class="countdown-item">
          <div class="countdown-number" id="days">--</div>
          <div class="countdown-label">Days</div>
        </div>
        <div class="countdown-item">
          <div class="countdown-number" id="hours">--</div>
          <div class="countdown-label">Hours</div>
        </div>
        <div class="countdown-item">
          <div class="countdown-number" id="minutes">--</div>
          <div class="countdown-label">Minutes</div>
        </div>
        <div class="countdown-item">
          <div class="countdown-number" id="seconds">--</div>
          <div class="countdown-label">Seconds</div>
        </div>
      </div>

      <div class="controls-row">
        <button class="pill-btn" id="snowToggle">‚ùÑ Snow: ON</button>
        <button class="pill-btn" id="sparkleToggle">‚ú® Sparkles: ON</button>
      </div>
    </section>

    <!-- Presents -->
    <section id="presents">
      <h2>üéÅ Open the Presents</h2>
      <p style="font-size:0.9rem; opacity:0.86;">
        Click a present to reveal a random Christmas challenge or message.  
        Each present gets a different one.
      </p>

      <div class="presents-grid">
        <div class="present" data-slot="1">
          <div class="present-box">
            <div class="present-label">Present #1</div>
          </div>
          <div class="present-text"></div>
        </div>
        <div class="present" data-slot="2">
          <div class="present-box">
            <div class="present-label">Present #2</div>
          </div>
          <div class="present-text"></div>
        </div>
        <div class="present" data-slot="3">
          <div class="present-box">
            <div class="present-label">Present #3</div>
          </div>
          <div class="present-text"></div>
        </div>
        <div class="present" data-slot="4">
          <div class="present-box">
            <div class="present-label">Present #4</div>
          </div>
          <div class="present-text"></div>
        </div>
      </div>

      <div class="present-message" id="presentMessage"></div>
    </section>

    <!-- Santa & Christmas Boss -->
    <section id="santa-boss">
      <h2>üéÖ Santa & üëë Christmas Boss Battle</h2>
      <p style="font-size:0.9rem; opacity:0.86; margin-bottom:10px;">
        Talk to Santa for Christmas jokes.  
        Then, IF you want, press Play to fight the crown Boss. If you don‚Äôt, it just sits there chill.
      </p>

      <div class="character-row">
        <!-- Santa -->
        <div class="character-card">
          <div class="character-face">üéÖ</div>
          <div class="character-name">Santa Claus</div>
          <div class="character-desc">
            Very jolly. Powered by cookies, hot chocolate, and terrible puns.
          </div>
          <div class="character-buttons">
            <button class="char-btn" id="santaJokeBtn">Tell me a joke</button>
            <button class="char-btn" id="santaPunBtn">Christmas pun</button>
            <button class="char-btn" id="santaTipBtn">Wholesome tip</button>
          </div>
          <div class="character-output" id="santaOutput">
            Ho ho ho! Click a button and I‚Äôll say something festive.
          </div>
        </div>

        <!-- Boss Game -->
        <div class="character-card">
          <div class="character-face">üßù‚Äç‚ôÇÔ∏èüëë</div>
          <div class="character-name">Christmas Boss Battle</div>
          <div class="character-desc">
            You are a small elf with a candy cane sword, ice bow, and a heavy mace.
            Boss has a huge crown and no face. Terrifying.
          </div>
          <div style="margin-bottom:6px; display:flex; flex-wrap:wrap; gap:6px;">
            <button class="char-btn" id="bossPlayBtn">‚ñ∂ Play Boss Battle</button>
            <button class="char-btn" id="bossStopBtn">‚èπ Stop</button>
          </div>
          <div class="boss-info">
            Controls (when playing): A / D or ‚Üê / ‚Üí to move, W or ‚Üë to jump,
            J = sword (4 dmg), K = ice arrow (3 dmg), L = mace (1 dmg, 7 dmg if you hit while in the air),
            E = hail pickup / stun (3 seconds).
            Double-click the game to reset while playing.
          </div>
          <canvas id="bossGame" width="480" height="260"></canvas>
          <div class="boss-game-text" id="bossGameText">
            Boss battle idle. Press ‚ÄúPlay Boss Battle‚Äù if you want to fight.
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer>
    Made with ‚ù§Ô∏è by Calvin ¬∑ ¬© 2025
  </footer>

  <script>
    // Tree lights toggle
    const tree = document.getElementById("tree");
    const treeLabel = document.getElementById("treeLabel");

    tree.addEventListener("click", () => {
      tree.classList.toggle("lights-on");
      const on = tree.classList.contains("lights-on");
      treeLabel.textContent = "Lights: " + (on ? "ON" : "OFF") + " (click to toggle)";
    });

    // Countdown
    const daysEl = document.getElementById("days");
    const hoursEl = document.getElementById("hours");
    const minutesEl = document.getElementById("minutes");
    const secondsEl = document.getElementById("seconds");

    function getNextChristmas() {
      const now = new Date();
      const year = (now.getMonth() === 11 && now.getDate() > 25)
        ? now.getFullYear() + 1
        : now.getFullYear();
      return new Date(year, 11, 25, 0, 0, 0, 0);
    }

    const christmasDate = getNextChristmas();

    function updateCountdown() {
      const now = new Date();
      const diff = christmasDate - now;

      if (diff <= 0) {
        daysEl.textContent = "0";
        hoursEl.textContent = "0";
        minutesEl.textContent = "0";
        secondsEl.textContent = "0";
        return;
      }

      const totalSeconds = Math.floor(diff / 1000);
      const days = Math.floor(totalSeconds / (60 * 60 * 24));
      const hours = Math.floor((totalSeconds % (60 * 60 * 24)) / (60 * 60));
      const minutes = Math.floor((totalSeconds % (60 * 60)) / 60);
      const seconds = totalSeconds % 60;

      daysEl.textContent = days;
      hoursEl.textContent = hours;
      minutesEl.textContent = minutes;
      secondsEl.textContent = seconds;
    }

    updateCountdown();
    setInterval(updateCountdown, 1000);

    // Snow
    let snowEnabled = true;
    const snowToggle = document.getElementById("snowToggle");

    function createSnowflake() {
      if (!snowEnabled) return;
      const snowflake = document.createElement("div");
      snowflake.className = "snowflake";
      const size = 4 + Math.random() * 6;
      snowflake.style.width = size + "px";
      snowflake.style.height = size + "px";
      snowflake.style.left = Math.random() * window.innerWidth + "px";
      snowflake.style.setProperty("--duration", (5 + Math.random() * 6) + "s");
      document.body.appendChild(snowflake);
      setTimeout(() => snowflake.remove(), 12000);
    }

    snowToggle.addEventListener("click", () => {
      snowEnabled = !snowEnabled;
      snowToggle.textContent = snowEnabled ? "‚ùÑ Snow: ON" : "‚ùÑ Snow: OFF";
      if (snowEnabled) {
        for (let i = 0; i < 30; i++) createSnowflake();
      }
    });

    for (let i = 0; i < 40; i++) createSnowflake();
    setInterval(createSnowflake, 400);

    // Sparkles
    let sparklesEnabled = true;
    const sparkleToggle = document.getElementById("sparkleToggle");

    sparkleToggle.addEventListener("click", () => {
      sparklesEnabled = !sparklesEnabled;
      sparkleToggle.textContent = sparklesEnabled ? "‚ú® Sparkles: ON" : "‚ú® Sparkles: OFF";
    });

    document.addEventListener("pointermove", (e) => {
      if (!sparklesEnabled) return;
      if (Math.random() > 0.35) return;
      const s = document.createElement("div");
      s.className = "sparkle";
      s.style.left = e.clientX + "px";
      s.style.top = e.clientY + "px";
      document.body.appendChild(s);
      setTimeout(() => s.remove(), 700);
    });

    // Presents (no repeats)
    const presents = document.querySelectorAll(".present");
    const presentMessage = document.getElementById("presentMessage");

    const presentMessages = [
      "üéÑ Challenge: Say ‚ÄúMerry Christmas‚Äù in 3 different languages.",
      "üéÅ Gratitude: Name 3 things you‚Äôre grateful for this year.",
      "‚ú® Mission: Do a silly Christmas dance for 10 seconds.",
      "üòä Task: Give someone a genuine compliment today.",
      "‚òï Quest: Make hot chocolate for someone in your family.",
      "üéÖ Fun: Do your best Santa laugh: HO HO HO!",
      "‚ùÑ Chill: Take 3 deep breaths and relax for a moment.",
      "üé∂ Game: Hum your favourite Christmas song for 15 seconds.",
      "üç™ Sneaky: Hide a cookie for future-you (but remember where).",
      "üåü Calm: Look around and find 3 things that make you feel cozy.",
      "üì∏ Memory: Take a photo of something that feels like ‚ÄòChristmas‚Äô to you.",
      "üíå Kindness: Send a nice message to someone you haven‚Äôt talked to in a while."
    ];

    function randomFrom(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    let availablePresentMessages = [...presentMessages];

    function getUniquePresentMessage() {
      if (availablePresentMessages.length === 0) {
        availablePresentMessages = [...presentMessages];
      }
      const idx = Math.floor(Math.random() * availablePresentMessages.length);
      const msg = availablePresentMessages[idx];
      availablePresentMessages.splice(idx, 1);
      return msg;
    }

    presents.forEach((present, index) => {
      present.addEventListener("click", () => {
        if (present.classList.contains("opened")) return;
        const msg = getUniquePresentMessage();
        const textDiv = present.querySelector(".present-text");
        if (textDiv) textDiv.textContent = msg;
        present.classList.add("opened");
        presentMessage.textContent =
          "You opened Present #" + (index + 1) + ": " + msg;
      });
    });

    // Santa interactions
    const santaOutput = document.getElementById("santaOutput");
    const santaJokeBtn = document.getElementById("santaJokeBtn");
    const santaPunBtn = document.getElementById("santaPunBtn");
    const santaTipBtn = document.getElementById("santaTipBtn");

    const santaJokes = [
      "Why did Santa go to music school? So he could improve his wrapping skills!",
      "What do elves learn in school? The elf-abet.",
      "Why was the snowman looking through the carrots? He was picking his nose.",
      "What do you call a cat on the beach at Christmas? Sandy Claws.",
      "Why did Santa‚Äôs helper see the doctor? Because he had low ‚Äòelf‚Äô esteem.",
      "What do you get if you cross a snowman and a dog? Frostbite.",
      "Why is it so cold at Christmas? Because it‚Äôs Decembrrrrr.",
      "What do you call a snowman with a six-pack? An abdominal snowman.",
      "Why did Santa‚Äôs reindeer practice their jokes? They wanted to sleigh the audience.",
      "What do you call Santa when he stops moving? Santa Pause.",
      "Why did the Christmas tree go to the barber? It needed a trim-twig.",
      "What do you get when you eat Christmas decorations? Tinsel-itis.",
      "Why did the ornament go to school? It wanted to be a little brighter.",
      "How does Santa keep his bathroom tiles immaculate? He uses Comet.",
      "What‚Äôs Santa‚Äôs favourite place to visit in school? The elf-eteria."
    ];

    const santaPuns = [
      "This Christmas, I‚Äôm on the ‚Äònice-ish‚Äô list. It‚Äôs‚Ä¶ a gray area.",
      "I told my tree we‚Äôd always be friends. It said, ‚ÄòI‚Äôm rooting for you.‚Äô",
      "I‚Äôm very ‚Äòpresent‚Äô this year. Mostly because I bought none in advance.",
      "Don‚Äôt mind my Christmas jokes. They‚Äôre snow laughing matter.",
      "I‚Äôm feeling extra Claus-trophobic with all this Christmas spirit.",
      "We‚Äôre having a tree-mendous time, aren‚Äôt we?",
      "You snow the drill: eat, nap, repeat.",
      "Yule be sorry if you skip dessert.",
      "I‚Äôm just here for the sleigh rides and side quests.",
      "My New Year‚Äôs resolution is 1080p. Got to see those Christmas lights clearly.",
      "Let‚Äôs not get too wrapped up in presents.",
      "I‚Äôve got high sleigh-esteem this year.",
      "This party is snow joke. It‚Äôs actually fun.",
      "If you‚Äôre cold, just stand in the corner. It‚Äôs usually 90 degrees."
    ];

    const santaTips = [
      "Santa says: The best gift you can give is your time and attention.",
      "Remember: It‚Äôs okay if everything isn‚Äôt perfect. Cozy > perfect.",
      "Take one small moment today just to breathe and enjoy where you are.",
      "Tell someone you appreciate them. It takes 5 seconds and lasts all day.",
      "You don‚Äôt need a perfect tree, just real laughter around it.",
      "Drink some water between the hot chocolate. Future-you will thank you.",
      "Try to remember one good thing about this year. That‚Äôs your real present.",
      "If things feel stressful, focus on one tiny nice thing: lights, music, a smell, a memory.",
      "Smile at someone today. You won‚Äôt know how much they needed it.",
      "It‚Äôs okay to be tired. Rest is part of the holiday, too.",
      "You‚Äôre allowed to enjoy small things even if everything isn‚Äôt perfect.",
      "Be kind to yourself the way you‚Äôre kind to your friends.",
      "Pick one tradition you love and do it properly instead of doing ten things badly.",
      "Sometimes the best Christmas upgrade is just turning your phone off for a bit."
    ];

    santaJokeBtn.addEventListener("click", () => {
      santaOutput.textContent = randomFrom(santaJokes);
    });

    santaPunBtn.addEventListener("click", () => {
      santaOutput.textContent = randomFrom(santaPuns);
    });

    santaTipBtn.addEventListener("click", () => {
      santaOutput.textContent = randomFrom(santaTips);
    });

    // ---- Christmas Boss Game (canvas) ----
    const canvas = document.getElementById("bossGame");
    const ctx = canvas.getContext("2d");
    const bossGameText = document.getElementById("bossGameText");
    const bossPlayBtn = document.getElementById("bossPlayBtn");
    const bossStopBtn = document.getElementById("bossStopBtn");

    let gameActive = false;

    const keys = {};
    document.addEventListener("keydown", (e) => {
      keys[e.key.toLowerCase()] = true;
    });
    document.addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    const groundY = canvas.height - 30;

    const player = {
      x: 60,
      y: groundY - 40,
      w: 26,
      h: 40,
      vx: 0,
      vy: 0,
      speed: 2.3,
      jump: -9.2, // higher jump
      onGround: false,
      facing: 1,
      hp: 120,
      maxHp: 120,
      swordTimer: 0,
      swordCooldown: 0,
      swordDidHit: false,
      bowCooldown: 0,
      maceTimer: 0,
      maceCooldown: 0,
      maceDidHit: false,
      carryingHail: false
    };

    const boss = {
      x: canvas.width - 120,
      y: groundY - 90,
      w: 60,
      h: 90,
      hp: 400,
      maxHp: 400,
      attackCooldown: 120,
      alive: true,
      stunTimer: 0,
      ramTimer: 0,
      ramDir: -1
    };

    const arrows = [];
    const snowballs = [];
    const icicles = [];
    const waves = [];
    const hailStones = [];
    const skeletons = [];
    const skeletonProjectiles = [];

    let lastTime = 0;
    let totalTime = 0;
    let contactCooldown = 0; // cooldown for boss touch damage (ms)
    let prevE = false;       // for hail pickup / throw edge detection
    let stunSpin = 0;        // for spinning stars around stunned boss
    let earthquakeTimer = 0; // ms

    const hitBossLines = [
      "You slash with your candy cane. The Boss: ‚ÄúThat‚Äôs *too* sweet!‚Äù",
      "Ice arrow hits! Boss complains: ‚ÄúI said ‚Äòno ice‚Äô!‚Äù",
      "Festive hit! The Boss drops a gingerbread man in shock.",
      "Your combo is so sparkly the Boss needs sunglasses.",
      "Boss: ‚ÄúStop. These vibes are‚Ä¶ annoyingly wholesome.‚Äù"
    ];

    const maceCritLines = [
      "Perfect jump bonk! The crown actually rattles.",
      "Mace crit! Boss: ‚ÄúThat was NOT in the Christmas manual.‚Äù",
      "You slam the crown with a full jump swing. Massive jingle-damage.",
      "The ground shakes. Somewhere, a Christmas tree applauds."
    ];

    const bossHitYouLines = [
      "Snowball to the face! That‚Äôs one way to chill out.",
      "Boss: ‚ÄúConsider that a free sample of winter.‚Äù",
      "You slip a bit. Boss laughs in evil jingle bells.",
      "You tank the hit like a Christmas tree tanks decorations."
    ];

    const winLines = [
      "Boss: ‚ÄúFine. I admit it. Christmas is‚Ä¶ kind of awesome.‚Äù",
      "He drops his evil crown and puts on a Santa hat.",
      "The battlefield turns into a very weird Christmas party."
    ];

    const loseLines = [
      "You fall. Santa yells from the sidelines: ‚ÄúTAKE A NAP AND TRY AGAIN.‚Äù",
      "Boss: ‚ÄúCome back when your candy cane game is stronger.‚Äù"
    ];

    function getBossPhase() {
      const ratio = boss.hp / boss.maxHp;
      if (ratio > 2 / 3) return 1;
      if (ratio > 1 / 3) return 2;
      return 3;
    }

    function resetGame() {
      player.x = 60;
      player.y = groundY - player.h;
      player.vx = 0;
      player.vy = 0;
      player.hp = player.maxHp;
      player.swordTimer = 0;
      player.swordCooldown = 0;
      player.swordDidHit = false;
      player.bowCooldown = 0;
      player.maceTimer = 0;
      player.maceCooldown = 0;
      player.maceDidHit = false;
      player.carryingHail = false;

      boss.x = canvas.width - 120;
      boss.y = groundY - boss.h;
      boss.hp = boss.maxHp;
      boss.attackCooldown = 120;
      boss.alive = true;
      boss.stunTimer = 0;
      boss.ramTimer = 0;
      boss.ramDir = -1;

      arrows.length = 0;
      snowballs.length = 0;
      icicles.length = 0;
      waves.length = 0;
      hailStones.length = 0;
      skeletons.length = 0;
      skeletonProjectiles.length = 0;

      contactCooldown = 0;
      stunSpin = 0;
      earthquakeTimer = 0;

      bossGameText.textContent =
        "Fight started! Move: A/D or ‚Üê/‚Üí, Jump: W/‚Üë, Sword: J (4 dmg), Bow: K (3 dmg), Mace: L (jump = big crit), E = hail stun.";
    }

    bossPlayBtn.addEventListener("click", () => {
      gameActive = true;
      resetGame();
    });

    bossStopBtn.addEventListener("click", () => {
      gameActive = false;
      bossGameText.textContent =
        "Boss battle stopped. Press ‚ÄúPlay Boss Battle‚Äù again if you want another round.";
    });

    function spawnArrow() {
      const speed = 4;
      arrows.push({
        x: player.x + player.w / 2 + player.facing * 12,
        y: player.y + player.h / 2,
        vx: player.facing * speed,
        w: 12,
        h: 3
      });
    }

    function spawnSnowball(dirOverride) {
      const dir =
        typeof dirOverride === "number"
          ? dirOverride
          : player.x < boss.x ? -1 : 1;
      snowballs.push({
        x: boss.x + boss.w / 2,
        y: boss.y + boss.h / 2,
        vx: dir * (2.4 + Math.random() * 0.8),
        vy: (Math.random() - 0.5) * 0.6,
        w: 10,
        h: 10
      });
    }

    function spawnIcicle(xPos) {
      icicles.push({
        x: xPos,
        y: -18,
        vy: 3.2 + Math.random() * 0.8,
        w: 10,
        h: 20
      });
    }

    function spawnWave() {
      const dir = player.x < boss.x ? -1 : 1; // goes towards player side
      waves.push({
        x: dir === -1 ? boss.x : boss.x + boss.w - 40,
        y: groundY - 8,
        vx: dir * 2.2,
        w: 40,
        h: 8
      });
    }

    function spawnHailStorm() {
      const count = 2 + Math.floor(Math.random() * 2); // 2‚Äì3 hail stones
      for (let i = 0; i < count; i++) {
        const x = 60 + Math.random() * (canvas.width - 120);
        hailStones.push({
          x: x,
          y: -25,
          vy: 3.4 + Math.random() * 0.9,
          w: 18,
          h: 18,
          onGround: false
        });
      }
    }

    function dropHailAtPlayer() {
      const size = 18;
      hailStones.push({
        x: player.x + player.w / 2 - size / 2,
        y: groundY - size,
        vy: 0,
        w: size,
        h: size,
        onGround: true
      });
    }

    // Skeleton helpers
    function spawnSkeletons() {
      const maxTotal = 3;
      if (skeletons.length >= maxTotal) return;
      const slotsLeft = maxTotal - skeletons.length;
      const toSpawn = 1 + Math.floor(Math.random() * Math.min(3, slotsLeft));
      for (let i = 0; i < toSpawn; i++) {
        const type = Math.random() < 0.5 ? "sword" : "bow";
        const startLeft = Math.random() < 0.5;
        const sk = {
          type,
          x: startLeft ? 40 : canvas.width - 80,
          y: groundY - 32,
          w: 22,
          h: 32,
          vx: 0,
          speed: type === "sword" ? 1.5 : 1.2,
          hp: type === "sword" ? 35 : 25,
          maxHp: type === "sword" ? 35 : 25,
          attackCooldown: 1000 + Math.random() * 500,
          contactCooldown: 0
        };
        skeletons.push(sk);
      }
      bossGameText.textContent =
        "Skeleton backup arrives! They hit weaker than the Boss but still hurt.";
    }

    function spawnSkeletonArrow(sk) {
      const playerCenter = player.x + player.w / 2;
      const dir = playerCenter > sk.x ? 1 : -1;
      skeletonProjectiles.push({
        x: sk.x + sk.w / 2 + dir * 6,
        y: sk.y + sk.h / 2,
        vx: dir * 2.8,
        w: 9,
        h: 3
      });
    }

    function startEarthquake() {
      earthquakeTimer = 5000; // 5 seconds
      boss.attackCooldown = 1000; // pause a bit
      bossGameText.textContent =
        "EARTHQUAKE! Screen wobbles, controls feel weird, and icicles are more likely!";
    }

    function startRamAttack() {
      boss.ramTimer = 1500; // ms
      const playerCenter = player.x + player.w / 2;
      const bossCenter = boss.x + boss.w / 2;
      boss.ramDir = playerCenter < bossCenter ? -1 : 1;
      boss.attackCooldown = 1600;
      bossGameText.textContent =
        "Boss charges across the arena! Don‚Äôt be in the way.";
    }

    function performBossAttack() {
      if (!boss.alive || boss.hp <= 0) return;
      const phase = getBossPhase();

      // Earthquake is its own special event
      if (phase >= 2 && earthquakeTimer <= 0 && Math.random() < 0.2) {
        startEarthquake();
        return;
      }

      const r = Math.random();
      const eqActive = earthquakeTimer > 0;

      // When earthquake is active: bias heavily toward icicles
      if (eqActive) {
        if (r < 0.6) {
          for (let i = 0; i < 7; i++) {
            const ix = 40 + Math.random() * (canvas.width - 80);
            spawnIcicle(ix);
          }
          boss.attackCooldown = 900 + Math.random() * 600;
          bossGameText.textContent =
            "Earthquake boosts icicle rain! Stay mobile.";
          return;
        }
        // else continue to normal / phase logic below
      }

      if (phase === 1) {
        // Original attacks only
        if (r < 0.32) {
          spawnSnowball();
          boss.attackCooldown = 800 + Math.random() * 500;
          bossGameText.textContent = "Boss throws a grumpy snowball.";
        } else if (r < 0.6) {
          spawnSnowball();
          spawnSnowball();
          spawnSnowball();
          boss.attackCooldown = 1000 + Math.random() * 600;
          bossGameText.textContent = "Triple snowball volley! Dodge like a festive ninja.";
        } else if (r < 0.82) {
          for (let i = 0; i < 6; i++) {
            const ix = 40 + Math.random() * (canvas.width - 80);
            spawnIcicle(ix);
          }
          boss.attackCooldown = 1200 + Math.random() * 800;
          bossGameText.textContent =
            "Icicle rain! Don‚Äôt stand where pointy things fall.";
        } else if (r < 0.96) {
          spawnWave();
          boss.attackCooldown = 900 + Math.random() * 700;
          bossGameText.textContent = "Ground shockwave! Jump it or eat it.";
        } else {
          spawnHailStorm();
          boss.attackCooldown = 1400 + Math.random() * 800;
          bossGameText.textContent =
            "Boss calls down GIANT hail. Do NOT tank that.";
        }
        return;
      }

      // Phase 2 & 3: include ram + skeletons, hail, etc.
      if (r < 0.23) {
        spawnSnowball();
        boss.attackCooldown = 700 + Math.random() * 400;
        bossGameText.textContent = "Boss throws a grumpy snowball.";
      } else if (r < 0.46) {
        spawnSnowball();
        spawnSnowball();
        spawnSnowball();
        boss.attackCooldown = 900 + Math.random() * 500;
        bossGameText.textContent = "Triple snowball volley! Dodge like a festive ninja.";
      } else if (r < 0.64) {
        for (let i = 0; i < 6; i++) {
          const ix = 40 + Math.random() * (canvas.width - 80);
          spawnIcicle(ix);
        }
        boss.attackCooldown = 1100 + Math.random() * 700;
        bossGameText.textContent =
          "Icicle rain! Don‚Äôt stand where pointy things fall.";
      } else if (r < 0.78) {
        spawnWave();
        boss.attackCooldown = 800 + Math.random() * 600;
        bossGameText.textContent = "Ground shockwave! Jump it or eat it.";
      } else if (r < 0.88) {
        // Ram attack
        startRamAttack();
      } else if (r < 0.96) {
        // Skeleton summon
        spawnSkeletons();
        boss.attackCooldown = 1200 + Math.random() * 800;
      } else {
        // Hail ‚Äì still rare
        spawnHailStorm();
        boss.attackCooldown = 1400 + Math.random() * 800;
        bossGameText.textContent =
          "Boss calls down GIANT hail. Do NOT tank that.";
      }
    }

    function rectsOverlap(a, b) {
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      );
    }

    function update(dt) {
      if (!gameActive) return;
      if (player.hp <= 0 || boss.hp <= 0) return;

      totalTime += dt;

      if (contactCooldown > 0) contactCooldown -= dt;
      if (earthquakeTimer > 0) {
        earthquakeTimer -= dt;
        if (earthquakeTimer <= 0) {
          earthquakeTimer = 0;
          bossGameText.textContent =
            "The ground stops wobbling. Controls feel normal again.";
        }
      }

      const eDown = !!keys["e"];
      const ePressed = eDown && !prevE; // edge
      prevE = eDown;

      // Movement input (can be inverted by earthquake)
      let moveLeft = keys["a"] || keys["arrowleft"];
      let moveRight = keys["d"] || keys["arrowright"];

      if (earthquakeTimer > 0) {
        // Swap left/right to feel "randomised"
        const tmp = moveLeft;
        moveLeft = moveRight;
        moveRight = tmp;
      }

      player.vx = 0;
      if (moveLeft) {
        player.vx = -player.speed;
        player.facing = -1;
      }
      if (moveRight) {
        player.vx = player.speed;
        player.facing = 1;
      }

      // Hail pickup / throw
      if (ePressed) {
        if (!player.carryingHail) {
          // Try to pick up hail on ground near player
          for (let i = hailStones.length - 1; i >= 0; i--) {
            const h = hailStones[i];
            if (!h.onGround) continue;
            const hailRect = { x: h.x, y: h.y, w: h.w, h: h.h };
            const playerRect = { x: player.x, y: player.y, w: player.w, h: player.h };
            if (rectsOverlap(hailRect, playerRect) ||
                Math.abs((h.x + h.w / 2) - (player.x + player.w / 2)) < 30) {
              hailStones.splice(i, 1);
              player.carryingHail = true;
              bossGameText.textContent =
                "You lifted a huge hail chunk! Move close, face the Boss and press E to stun.";
              break;
            }
          }
        } else {
          // Currently carrying hail: try to stun
          if (boss.alive && boss.hp > 0) {
            const playerCenter = player.x + player.w / 2;
            const bossCenter = boss.x + boss.w / 2;
            const dirToBoss = bossCenter > playerCenter ? 1 : -1;
            const facingBoss = player.facing === dirToBoss;
            const distance = Math.abs(bossCenter - playerCenter);

            if (facingBoss && distance < 200) {
              // Stun for 3 seconds
              boss.stunTimer = 3000;
              boss.attackCooldown = 3000;
              boss.ramTimer = 0; // cancel any ram
              player.carryingHail = false;
              bossGameText.textContent =
                "Hail slam! Boss is stunned for 3 seconds. Go crazy!";
            } else {
              // Drop hail on ground instead of deleting it
              dropHailAtPlayer();
              player.carryingHail = false;
              bossGameText.textContent =
                "You drop the hail. Try facing the Boss and being a bit closer.";
            }
          } else {
            // Boss already dead, just drop hail on ground
            dropHailAtPlayer();
            player.carryingHail = false;
          }
        }
      }

      // Jump (disabled while carrying hail)
      if (!player.carryingHail && (keys["w"] || keys["arrowup"]) && player.onGround) {
        player.vy = player.jump;
        player.onGround = false;
      }

      // Sword attack (4 dmg, once per swing) ‚Äì disabled while carrying hail
      if (!player.carryingHail && (keys["j"] || keys[" "]) && player.swordCooldown <= 0) {
        player.swordTimer = 180;
        player.swordCooldown = 320;
        player.swordDidHit = false;
      }

      // Bow attack (3 dmg per arrow) ‚Äì disabled while carrying hail
      if (!player.carryingHail && keys["k"]) {
        if (!player.bowCooldown || player.bowCooldown <= 0) {
          spawnArrow();
          player.bowCooldown = 420;
        }
      }

      // Mace attack ‚Äì disabled while carrying hail
      if (!player.carryingHail && keys["l"] && player.maceCooldown <= 0) {
        player.maceTimer = 200;
        player.maceCooldown = 550;
        player.maceDidHit = false;
      }

      if (player.swordTimer > 0) player.swordTimer -= dt;
      if (player.swordCooldown > 0) player.swordCooldown -= dt;
      if (player.bowCooldown > 0) player.bowCooldown -= dt;
      if (player.maceTimer > 0) player.maceTimer -= dt;
      if (player.maceCooldown > 0) player.maceCooldown -= dt;

      // Apply movement
      player.x += player.vx;
      player.vy += 0.35; // gravity
      player.y += player.vy;

      // Ground collision
      if (player.y + player.h >= groundY) {
        player.y = groundY - player.h;
        player.vy = 0;
        player.onGround = true;
      } else {
        player.onGround = false;
      }

      // World bounds
      if (player.x < 0) player.x = 0;
      if (player.x + player.w > canvas.width) player.x = canvas.width - player.w;

      // Boss movement (ram + basic wobble)
      if (boss.alive) {
        if (boss.stunTimer > 0) {
          boss.stunTimer -= dt;
          stunSpin += dt * 0.01;  // spin stars while stunned
          if (boss.stunTimer <= 0) {
            boss.stunTimer = 0;
            boss.attackCooldown = 600 + Math.random() * 400;
            bossGameText.textContent =
              "Boss shakes off the hail stun. Back to chaos.";
          }
        } else if (boss.ramTimer > 0) {
          boss.ramTimer -= dt;
          boss.x += boss.ramDir * 4.3;
          if (boss.x < 20) {
            boss.x = 20;
            boss.ramDir = 1;
          }
          if (boss.x + boss.w > canvas.width - 20) {
            boss.x = canvas.width - 20 - boss.w;
            boss.ramDir = -1;
          }
          if (boss.ramTimer <= 0) {
            boss.ramTimer = 0;
            boss.attackCooldown = 800 + Math.random() * 500;
            bossGameText.textContent =
              "Ram attack ends. The Boss slows down again.";
          }
        } else {
          boss.attackCooldown -= dt;
          if (boss.attackCooldown <= 0) {
            performBossAttack();
          }
        }
      }

      // Player collision with boss (solid + chip damage with cooldown)
      if (boss.alive && boss.hp > 0) {
        const playerRect = { x: player.x, y: player.y, w: player.w, h: player.h };
        const bossRect = { x: boss.x, y: boss.y, w: boss.w, h: boss.h };

        if (rectsOverlap(playerRect, bossRect)) {
          const playerCenter = player.x + player.w / 2;
          const bossCenter = boss.x + boss.w / 2;

          if (playerCenter < bossCenter) {
            player.x = boss.x - player.w; // push left
          } else {
            player.x = boss.x + boss.w;   // push right
          }

          player.vx = 0;

          const contactDamage = 4;
          if (player.hp > 0 && contactCooldown <= 0) {
            player.hp = Math.max(0, player.hp - contactDamage);
            contactCooldown = 700; // ms
            if (player.hp === 0) {
              bossGameText.textContent =
                "You tried to body-check the Boss and got flattened.";
            } else {
              bossGameText.textContent =
                "You bump into the Boss and get shoved back. No friendly hugs.";
            }
          }
        }
      }

      // Arrows (3 dmg)
      for (let i = arrows.length - 1; i >= 0; i--) {
        const a = arrows[i];
        a.x += a.vx;
        if (a.x < -20 || a.x > canvas.width + 20) {
          arrows.splice(i, 1);
          continue;
        }
        if (boss.alive && boss.hp > 0 && rectsOverlap(a, boss)) {
          boss.hp -= 3;
          boss.hp = Math.max(0, boss.hp);
          arrows.splice(i, 1);
          if (boss.hp === 0) {
            boss.alive = false;
            bossGameText.textContent = randomFrom(winLines);
          } else {
            bossGameText.textContent = randomFrom(hitBossLines);
          }
        }
      }

      // Snowballs
      for (let i = snowballs.length - 1; i >= 0; i--) {
        const s = snowballs[i];
        s.x += s.vx;
        s.y += s.vy;
        if (s.x < -30 || s.x > canvas.width + 30 || s.y > canvas.height + 30) {
          snowballs.splice(i, 1);
          continue;
        }
        if (player.hp > 0 && rectsOverlap(s, player)) {
          player.hp -= 8;
          player.hp = Math.max(0, player.hp);
          snowballs.splice(i, 1);
          if (player.hp === 0) {
            bossGameText.textContent = randomFrom(loseLines);
          } else {
            bossGameText.textContent = randomFrom(bossHitYouLines);
          }
        }
      }

      // Icicles
      for (let i = icicles.length - 1; i >= 0; i--) {
        const ic = icicles[i];
        ic.y += ic.vy;
        if (ic.y > canvas.height + 20) {
          icicles.splice(i, 1);
          continue;
        }
        if (player.hp > 0 && rectsOverlap(ic, player)) {
          player.hp -= 14;
          player.hp = Math.max(0, player.hp);
          icicles.splice(i, 1);
          if (player.hp === 0) {
            bossGameText.textContent = randomFrom(loseLines);
          } else {
            bossGameText.textContent = "Icicle hit! That‚Äôs one spicy snow-cone.";
          }
        }
      }

      // Ground waves
      for (let i = waves.length - 1; i >= 0; i--) {
        const w = waves[i];
        w.x += w.vx;
        if (w.x < -60 || w.x > canvas.width + 60) {
          waves.splice(i, 1);
          continue;
        }
        if (player.hp > 0 && rectsOverlap(w, player)) {
          player.hp -= 16;
          player.hp = Math.max(0, player.hp);
          waves.splice(i, 1);
          if (player.hp === 0) {
            bossGameText.textContent = randomFrom(loseLines);
          } else {
            bossGameText.textContent =
              "Ground wave smacks your ankles. Jump earlier!";
          }
        }
      }

      // Hail stones (50% HP if hit; become pickups on ground)
      const hailDamage = Math.ceil(player.maxHp * 0.5);
      for (let i = hailStones.length - 1; i >= 0; i--) {
        const h = hailStones[i];
        if (!h.onGround) {
          h.y += h.vy;
          // Collision with player midair
          const hailRect = { x: h.x, y: h.y, w: h.w, h: h.h };
          const playerRect = { x: player.x, y: player.y, w: player.w, h: player.h };
          if (player.hp > 0 && rectsOverlap(hailRect, playerRect)) {
            player.hp -= hailDamage;
            player.hp = Math.max(0, player.hp);
            hailStones.splice(i, 1);
            if (player.hp === 0) {
              bossGameText.textContent =
                "You tried to tank the hail. It tanked you instead.";
            } else {
              bossGameText.textContent =
                "Hail smash! That took a HUGE chunk of HP.";
            }
            continue;
          }

          // Land on ground
          if (h.y + h.h >= groundY) {
            h.y = groundY - h.h;
            h.vy = 0;
            h.onGround = true;
          }
        }
      }

      // Skeletons
      for (let i = skeletons.length - 1; i >= 0; i--) {
        const sk = skeletons[i];
        if (sk.contactCooldown > 0) sk.contactCooldown -= dt;

        const playerCenter = player.x + player.w / 2;
        const skCenter = sk.x + sk.w / 2;
        const dir = playerCenter > skCenter ? 1 : -1;

        if (sk.type === "sword") {
          // Walk towards player
          sk.vx = dir * sk.speed;
          sk.x += sk.vx;
        } else {
          // Bow skeleton tries to keep some distance
          const dist = Math.abs(playerCenter - skCenter);
          if (dist < 80) {
            sk.vx = -dir * sk.speed; // back off
          } else if (dist > 140) {
            sk.vx = dir * 0.8; // move closer slowly
          } else {
            sk.vx = 0;
          }
          sk.x += sk.vx;
        }

        // World bounds
        if (sk.x < 10) sk.x = 10;
        if (sk.x + sk.w > canvas.width - 10) sk.x = canvas.width - 10 - sk.w;

        // Contact damage with player (weaker than boss)
        const skRect = { x: sk.x, y: sk.y, w: sk.w, h: sk.h };
        const playerRect = { x: player.x, y: player.y, w: player.w, h: player.h };
        if (player.hp > 0 && rectsOverlap(skRect, playerRect)) {
          if (sk.contactCooldown <= 0) {
            const dmg = sk.type === "sword" ? 3 : 2;
            player.hp = Math.max(0, player.hp - dmg);
            sk.contactCooldown = 700;
            if (player.hp === 0) {
              bossGameText.textContent =
                "Skeleton bonk finishes you off. Spooky.";
            } else {
              bossGameText.textContent =
                "Skeleton hits you. Not as bad as the Boss, but it still hurts.";
            }
          }
        }

        // Bow skeleton shooting
        sk.attackCooldown -= dt;
        if (sk.type === "bow" && sk.attackCooldown <= 0) {
          spawnSkeletonArrow(sk);
          sk.attackCooldown = 1500 + Math.random() * 800;
        }

        // Remove if dead
        if (sk.hp <= 0) {
          skeletons.splice(i, 1);
        }
      }

      // Skeleton projectiles
      for (let i = skeletonProjectiles.length - 1; i >= 0; i--) {
        const p = skeletonProjectiles[i];
        p.x += p.vx;
        if (p.x < -20 || p.x > canvas.width + 20) {
          skeletonProjectiles.splice(i, 1);
          continue;
        }
        if (player.hp > 0 && rectsOverlap(p, player)) {
          player.hp = Math.max(0, player.hp - 6);
          skeletonProjectiles.splice(i, 1);
          if (player.hp === 0) {
            bossGameText.textContent =
              "Skeleton arrow takes you out while you‚Äôre distracted.";
          } else {
            bossGameText.textContent =
              "Arrow from a skeleton archer clips you.";
          }
        }
      }

      // Sword hit (4 dmg, once per swing)
      if (player.swordTimer > 0 && !player.swordDidHit && boss.alive && boss.hp > 0) {
        const reach = 20;
        const swordRect = {
          x: player.facing === 1 ? player.x + player.w : player.x - reach,
          y: player.y + 6,
          w: reach,
          h: player.h - 12
        };
        if (rectsOverlap(swordRect, boss)) {
          boss.hp -= 4;
          boss.hp = Math.max(0, boss.hp);
          player.swordDidHit = true;
          if (boss.hp === 0) {
            boss.alive = false;
            bossGameText.textContent = randomFrom(winLines);
          } else {
            bossGameText.textContent = randomFrom(hitBossLines);
          }
        }
        // sword can also hit skeletons
        for (let i = skeletons.length - 1; i >= 0; i--) {
          const sk = skeletons[i];
          const skRect = { x: sk.x, y: sk.y, w: sk.w, h: sk.h };
          if (rectsOverlap(swordRect, skRect)) {
            sk.hp -= 6;
          }
        }
      }

      // Mace hit (1 dmg normal, 7 dmg crit)
      if (player.maceTimer > 0 && !player.maceDidHit && boss.alive && boss.hp > 0) {
        const reach = 24;
        const maceRect = {
          x: player.facing === 1 ? player.x + player.w : player.x - reach,
          y: player.y - 4,
          w: reach,
          h: player.h + 8
        };
        if (rectsOverlap(maceRect, boss)) {
          const isCrit = !player.onGround && Math.abs(player.vy) > 0.4;
          const dmg = isCrit ? 7 : 1;
          boss.hp -= dmg;
          boss.hp = Math.max(0, boss.hp);
          player.maceDidHit = true;
          if (boss.hp === 0) {
            boss.alive = false;
            bossGameText.textContent = randomFrom(winLines);
          } else {
            bossGameText.textContent = isCrit
              ? randomFrom(maceCritLines)
              : randomFrom(hitBossLines);
          }
        }
        // mace can also hit skeletons
        for (let i = skeletons.length - 1; i >= 0; i--) {
          const sk = skeletons[i];
          const skRect = { x: sk.x, y: sk.y, w: sk.w, h: sk.h };
          if (rectsOverlap(maceRect, skRect)) {
            const isCrit = !player.onGround && Math.abs(player.vy) > 0.4;
            sk.hp -= isCrit ? 9 : 3;
          }
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Screen wobble during earthquake
      ctx.save();
      if (earthquakeTimer > 0) {
        const t = totalTime * 0.02;
        const dx = Math.sin(t) * 3;
        const dy = Math.cos(t * 1.2) * 2;
        ctx.translate(dx, dy);
      }

      const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
      grd.addColorStop(0, "#020617");
      grd.addColorStop(1, "#0b1730");
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Ground
      ctx.fillStyle = "#0c1f3a";
      ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

      if (!gameActive) {
        // Idle / menu screen
        ctx.fillStyle = "rgba(15,23,42,0.9)";
        ctx.fillRect(40, 40, canvas.width - 80, canvas.height - 80);
        ctx.strokeStyle = "rgba(148,163,184,0.9)";
        ctx.strokeRect(40, 40, canvas.width - 80, canvas.height - 80);
        ctx.fillStyle = "#e5e7eb";
        ctx.font = "14px system-ui";
        ctx.fillText("Christmas Boss Battle", 80, 80);
        ctx.font = "11px system-ui";
        ctx.fillText("Press the ‚ÄúPlay Boss Battle‚Äù button to start fighting.", 80, 100);
        ctx.fillText("Or ignore it and just enjoy the snow & jokes. Up to you.", 80, 116);
        ctx.restore();
        return;
      }

      // HP bars
      const pRatio = player.hp / player.maxHp;
      const bRatio = boss.hp / boss.maxHp;
      const phase = getBossPhase();

      // Player HP
      ctx.fillStyle = "#ffffff";
      ctx.font = "10px system-ui";
      ctx.fillText("Elf HP", 10, 12);
      ctx.strokeStyle = "#ffffff";
      ctx.strokeRect(10, 16, 80, 8);
      ctx.fillStyle = "#4ade80";
      ctx.fillRect(10, 16, 80 * pRatio, 8);

      // Boss HP 3-phase bar
      const bx = canvas.width - 110;
      const by = 8;
      const bw = 100;
      const bh = 10;

      ctx.fillStyle = "#ffffff";
      ctx.font = "10px system-ui";
      ctx.fillText("Boss HP", bx, by - 2);

      // Segment background
      ctx.strokeStyle = "#ffffff";
      ctx.strokeRect(bx, by, bw, bh);
      ctx.strokeStyle = "rgba(148,163,184,0.8)";
      ctx.beginPath();
      ctx.moveTo(bx + bw / 3, by);
      ctx.lineTo(bx + bw / 3, by + bh);
      ctx.moveTo(bx + (2 * bw) / 3, by);
      ctx.lineTo(bx + (2 * bw) / 3, by + bh);
      ctx.stroke();

      // Fill current HP
      const hpWidth = bw * bRatio;
      ctx.fillStyle = phase === 1 ? "#f97373" : phase === 2 ? "#fb923c" : "#facc15";
      ctx.fillRect(bx, by, hpWidth, bh);

      ctx.fillStyle = "#e5e7eb";
      ctx.font = "9px system-ui";
      ctx.fillText("Phase " + phase, bx + 28, by + 20);

      // Player
      ctx.fillStyle = "#22c55e";
      ctx.fillRect(player.x, player.y, player.w, player.h);
      ctx.fillStyle = "#16a34a";
      ctx.beginPath();
      ctx.moveTo(player.x + player.w / 2, player.y - 10);
      ctx.lineTo(player.x, player.y + 5);
      ctx.lineTo(player.x + player.w, player.y + 5);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(player.x + player.w / 2 - 2, player.y - 12, 4, 4);

      // If carrying hail: raised arms + hail above head
      if (player.carryingHail) {
        ctx.strokeStyle = "#bbf7fe";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(player.x + 5, player.y + 15);
        ctx.lineTo(player.x - 2, player.y - 5);
        ctx.moveTo(player.x + player.w - 5, player.y + 15);
        ctx.lineTo(player.x + player.w + 2, player.y - 5);
        ctx.stroke();

        ctx.fillStyle = "#bfdbfe";
        ctx.beginPath();
        ctx.arc(player.x + player.w / 2, player.y - 10, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#93c5fd";
        ctx.stroke();
      }

      // Sword
      if (player.swordTimer > 0) {
        ctx.save();
        const baseX = player.facing === 1 ? player.x + player.w : player.x;
        const baseY = player.y + player.h / 2;
        ctx.translate(baseX, baseY);
        const angle = player.facing === 1 ? 0.4 : Math.PI - 0.4;
        ctx.rotate(angle);
        const swordLen = 26;
        ctx.fillStyle = "#fee2e2";
        ctx.fillRect(0, -2, swordLen, 4);
        ctx.fillStyle = "#f97373";
        for (let i = 0; i < swordLen; i += 6) {
          ctx.fillRect(i, -2, 3, 4);
        }
        ctx.restore();
      }

      // Mace
      if (player.maceTimer > 0) {
        ctx.save();
        const baseX = player.facing === 1 ? player.x + player.w : player.x;
        const baseY = player.y + player.h / 2;
        ctx.translate(baseX, baseY);
        const angle = player.facing === 1 ? -0.3 : Math.PI + 0.3;
        ctx.rotate(angle);
        ctx.strokeStyle = "#e5e7eb";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(18, 0);
        ctx.stroke();
        ctx.fillStyle = "#facc15";
        ctx.beginPath();
        ctx.arc(22, 0, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // Player arrows
      ctx.fillStyle = "#bae6fd";
      arrows.forEach((a) => {
        ctx.fillRect(a.x, a.y, a.w, a.h);
      });

      // Boss with only crown (and spinning stars if stunned)
      if (boss.hp > 0) {
        const bossGrd = ctx.createLinearGradient(boss.x, boss.y, boss.x, boss.y + boss.h);
        bossGrd.addColorStop(0, "#ef4444");
        bossGrd.addColorStop(1, "#b91c1c");
        ctx.fillStyle = bossGrd;
        ctx.fillRect(boss.x, boss.y, boss.w, boss.h);

        ctx.fillStyle = "#fde047";
        ctx.fillRect(boss.x + 5, boss.y - 14, boss.w - 10, 12);
        ctx.beginPath();
        ctx.moveTo(boss.x + 5, boss.y - 14);
        ctx.lineTo(boss.x + 15, boss.y - 26);
        ctx.lineTo(boss.x + 30, boss.y - 14);
        ctx.lineTo(boss.x + 45, boss.y - 26);
        ctx.lineTo(boss.x + boss.w - 5, boss.y - 14);
        ctx.closePath();
        ctx.fill();

        if (boss.stunTimer > 0) {
          // spinning stars around boss
          const cx = boss.x + boss.w / 2;
          const cy = boss.y + boss.h / 2;
          const starCount = 5;
          const radiusX = boss.w;
          const radiusY = boss.h * 0.6;

          ctx.save();
          ctx.translate(cx, cy - 8);
          ctx.strokeStyle = "#facc15";
          ctx.lineWidth = 2;

          for (let i = 0; i < starCount; i++) {
            const angle = stunSpin + (i * (Math.PI * 2 / starCount));
            const sx = Math.cos(angle) * radiusX;
            const sy = Math.sin(angle) * radiusY;

            ctx.beginPath();
            ctx.moveTo(sx, sy - 4);
            ctx.lineTo(sx, sy + 4);
            ctx.moveTo(sx - 4, sy);
            ctx.lineTo(sx + 4, sy);
            ctx.stroke();
          }
          ctx.restore();
        }
      } else {
        ctx.fillStyle = "#9ca3af";
        ctx.fillRect(boss.x, boss.y + boss.h - 20, boss.w, 20);
      }

      // Snowballs
      snowballs.forEach((s) => {
        const rad = s.w / 2;
        ctx.fillStyle = "#e5f2ff";
        ctx.beginPath();
        ctx.arc(s.x + rad, s.y + rad, rad, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "rgba(148,163,184,0.8)";
        ctx.stroke();
      });

      // Icicles
      icicles.forEach((ic) => {
        ctx.fillStyle = "#e0f2fe";
        ctx.beginPath();
        ctx.moveTo(ic.x + ic.w / 2, ic.y);
        ctx.lineTo(ic.x, ic.y + ic.h);
        ctx.lineTo(ic.x + ic.w, ic.y + ic.h);
        ctx.closePath();
        ctx.fill();
      });

      // Ground waves
      waves.forEach((w) => {
        const waveGrd = ctx.createLinearGradient(w.x, w.y, w.x + w.w, w.y);
        waveGrd.addColorStop(0, "#38bdf8");
        waveGrd.addColorStop(1, "#a855f7");
        ctx.fillStyle = waveGrd;
        ctx.fillRect(w.x, w.y, w.w, w.h);
      });

      // Hail stones
      hailStones.forEach((h) => {
        const rad = h.w / 2;
        ctx.fillStyle = "#bfdbfe";
        ctx.beginPath();
        ctx.arc(h.x + rad, h.y + rad, rad, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#93c5fd";
        ctx.stroke();
      });

      // Skeletons (with HP bar)
      skeletons.forEach((sk) => {
        ctx.fillStyle = sk.type === "sword" ? "#e5e7eb" : "#cbd5f5";
        ctx.fillRect(sk.x, sk.y, sk.w, sk.h);

        // Head
        ctx.fillStyle = "#f9fafb";
        ctx.fillRect(sk.x + 4, sk.y - 8, sk.w - 8, 8);

        // HP bar above
        const ratio = sk.hp / sk.maxHp;
        const sx = sk.x;
        const sy = sk.y - 12;
        const sw = sk.w;
        const sh = 4;
        ctx.strokeStyle = "#ffffff";
        ctx.strokeRect(sx, sy, sw, sh);
        ctx.fillStyle = "#22c55e";
        ctx.fillRect(sx, sy, sw * ratio, sh);
      });

      // Skeleton projectiles
      ctx.fillStyle = "#fbbf24";
      skeletonProjectiles.forEach((p) => {
        ctx.fillRect(p.x, p.y, p.w, p.h);
      });

      ctx.restore(); // end wobble transform
    }

    function gameLoop(timestamp) {
      const dt = timestamp - lastTime;
      lastTime = timestamp;
      update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }

    canvas.addEventListener("dblclick", () => {
      if (gameActive) resetGame();
    });

    bossGameText.textContent =
      "Boss battle idle. Press ‚ÄúPlay Boss Battle‚Äù if you want to fight. Or don‚Äôt. It‚Äôs Christmas.";

    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
